#include "stdio.h"

//含有测试打印的代码 按需删除

//队列
template<class DATA>class PQUEUE {
	int isempty() {
		if (end - head)return 0; return 1;
	};
public:
	PQUEUE<DATA>() {
		PQUEUE<DATA>(64);
	};
	PQUEUE<DATA>(int min = 64) {
		minl = min;
		v = new DATA*[minl];
		size = 64;
		for (i = 0; i < size; i++)
			v[i] = NULL;
	};
	~PQUEUE<DATA>() {
		for (i = 0; i < size; i++)
			v[i] = NULL;
		delete[]v;
	};
private:
	int i, j;
	//初始队列长度
	int minl = 64;
	//扩大/缩小队列的量
	int changel = minl, shrinkl = minl / 4;
	void movedatatoleft(DATA**dest, DATA**src) {
		if (isempty())return;
		int size = end - head;
		for (i = 0; i < size; i++) {
			dest[i] = src[i + head];
			src[i + head] = NULL;
		}
		return;
	}
	//先考虑缩小队列的可能性。缩小队列的时候总是缩小到minl+changel的一定倍数。
	void changesize(int needmorespace = 1) {
		int len = end + needmorespace; if (head >= shrinkl)len -= head;
		int sizenew = (len - minl) / changel*changel + changel + minl;
		if (isempty())sizenew = minl;
		if (sizenew == size) {
			movedatatoleft(v, v);
			return;
		}
		DATA**temp = new DATA*[sizenew];
		for (i = 0; i < sizenew; i++)
			temp[i] = NULL;
		movedatatoleft(temp, v);
		delete[]v; v = NULL;
		v = temp; temp = NULL;
		head = 0; end = len - needmorespace; size = sizenew;
		return;
	}
public:
	int head, end, size;
	DATA**v = NULL;

	void push(DATA* src) {
		if (isempty()) { head = 0; end = 0; }
		if (end == size)changesize(1);
		if (end > size)
			scanf("%d", &j);
		v[end] = src; end++;
	}
	DATA* pop() {
		if (isempty())return NULL;
		DATA*data = v[head];
		v[head] = NULL; head++;
		if (isempty())changesize(0);
		return data;
	}
};

//有序链表 ord:0 链表首存放最低值 1 反之  key:需要重载 = < == 三个运算符
template<class KEY,class DATA>class PLIST_WITH_ORD {
	int isempty() {
		if (head == NULL)return 1; return 0;
	};
public:
	struct NOTE{
		KEY key; DATA*data = NULL;
		NOTE*next = NULL;
	};
	PLIST_WITH_ORD<KEY,DATA>() {
		PLIST_WITH_ORD(0);
	}
	PLIST_WITH_ORD<KEY, DATA>(int ord = 0) {
		this->ord = ord;
	};
	~PLIST_WITH_ORD<KEY, DATA>() {
		NOTE*temp = NULL;
		while (head) {
			temp = head;
			head = head->next;
			temp->data = NULL; temp->next = NULL;
			delete temp; temp = NULL;
		}
		return;
	};
private:
	int ord;
	NOTE* newnote(KEY key, DATA*data) {
		NOTE*temp = new NOTE;
		temp->key = key;
		temp->data = data;
		return temp;
	}
public:
	NOTE *head = NULL;
	NOTE* search(KEY key) {
		if (isempty())return NULL;
		if (key < (head->key)^ord)return NULL;
		NOTE*cur = head;
		while (cur&&!(cur->key == key))cur = cur->next;
		return cur;
	}
	//相同值会靠后延长
	void push(KEY key, DATA*data) {
		NOTE*temp = newnote(key, data);
		if (isempty()) {
			head = temp;
			return;
		}
		if (key < (head->key)^ord) {
			temp->next = head;
			head = temp;
			return;
		}
		NOTE*cur = head;
		while (cur->next && (cur->next->key < key^ord))cur = cur->next;
		temp->next = cur->next;
		cur->next = temp;
		return;
	}
	void pop() {
		if (isempty()) {
			return;
		}
		head->data = NULL;
		NOTE*temp = head; head = head->next;
		delete temp; temp = NULL;
		return;
	}
};

//有序链表+队列

#define qc QC<KEY,DATA>
#define pqueue PQUEUE<DATA>
#define plist PLIST_WITH_ORD<KEY, pqueue>

template<class KEY, class DATA>class QC :plist {
public:	
	qc() : plist(0) {};
	void push(KEY key, DATA*data) {
		typename plist::NOTE* temp = plist::search(key);
		if (temp) {
			temp->data->push(data);
			return;
		}
		pqueue*p = new pqueue(64);
		p->push(data);
		plist::push(key, p);
		p = NULL; return;
	}
	DATA* pop() {
		if (plist::head == NULL)return NULL;
		pqueue*p = plist::head->data;
		DATA*data = p->pop();
		if (p->end - p->head == 0) {
			delete p; p = NULL;
			plist::pop();
		}
		return data;
	}


	//将队列中的内容打印到控制台

	void printdata() {
		if (plist::head == NULL)return;
		int count = 0, s, e, i;
		typename plist::NOTE*temp = plist::head;
		//首项
		s = temp->data->head; e = temp->data->end;
		printf("(%d %d)|", temp->data->v[s]->x, temp->data->v[s]->y);
		while (temp) {
			s = temp->data->head; e = temp->data->end;
			count += e - s;
			for (i = s; i < e; i++)
				printf("%d|", temp->data->v[i]->color);
			temp = temp->next;
		}
		printf("\n%d\n", count);
		return;
	}

	//将队列中的内容打印到控制台 end


};

#undef qc
#undef pqueue
#undef plist

class CELL {
public:
	int x, y, value;
	int color;
	void set(int i, int j, char c) {
		x = i; y = j; color = 0;
		switch (c) {
		case '#':value = 0; color = 1; break;
		case '.':value = 1; break;
		case 'x':value = 2; break;
		case 'a':value = 3; break;
		case 'r':value = 4; break;
		default:break;
		}
		return;
	}
	int setcolor(int c) {
		switch (value) {
		case 1:color = c + 1; break;
		case 2:color = c + 1; break;
		default:return 0;
		}
		return 1;
	}
};

class SOLVE {
	int i, j;
public:
	int m, n;
	CELL**cell = NULL;
	QC<int, CELL>  qc;
	int count;

	void newandset(int m,int n) {
		this->m = m; this->n = n;
		cell = new CELL*[m];
		for (i = 0; i < m; i++)
			cell[i] = new CELL[n];
		return;
	}
	void del() {
		qc.~QC<int, CELL>();
		for (i = 0; i < m; i++)delete[]cell[i];
		delete[]cell;
		return;
	}

	int judge(CELL*c) {
		if (c != NULL&&c->color == 0)return 1;
		return 0;
	}
	CELL*around(CELL*c, int ord) {
		int i = c->x; int j = c->y;
		switch (ord) {
		case 3:j -= 1; break;
		case 4:j += 1; break;
		}
		switch (ord) {
		case 1:i -= 1; break;
		case 2:i += 1; break;
		}
		if (0 <= i&&i < m && 0 <= j&&j < n)
			return cell[i] + j;
		return NULL;
	}
	//! 打印状态=无
	int fun() {
		int i, j;
		for (i = 0; i < m; i++)
			for (j = 0; j < n; j++)
				if (cell[i][j].value == 4)
				{
					cell[i][j].color = 1;
					goto A;
				}
	A:	
		qc.push(cell[i][j].color, cell[i] + j);
		CELL *now = NULL, *temp = NULL;
		while (1) {
			//qc.printdata();
			now = qc.pop();
			//退出条件:无路可走
			if (now == NULL)return 0;
			//继续
			for (i = 1; i <= 4; i++) {
				temp = around(now, i);
				if (temp == NULL)continue;
				//退出条件:找到
				if (temp->value == 3) {
					return now->color;
				}
				//继续
				if (judge(temp))
					if (temp->setcolor(now->color))
						qc.push(temp->color, temp);
			}
		}
	}

	void printa(CELL* c) {
		switch (c->value)
		{
		case 0:printf("#"); break;
		case 1:printf("."); break;
		case 2:printf("x"); break;
		case 3:printf("0"); break;
		case 4:printf("0"); break;
		default:
			break;
		};
		printf("|");
		return;
	}
	void print() {
		int i, j;
		for (i = 0; i < m; i++) {
			for (j = 0; j < n; j++)
				printa(cell[i] + j);
			printf("\n");
		}
		return;
	}
	void printpath() {

		char **map;
		map = new char*[m];
		for (i = 0; i < m; i++) {
			map[i] = new char[n];
			for (j = 0; j < n; j++)
				map[i][j] = ' ';
		}

		int x, y;
		for (i = 0; i < m; i++)
			for (j = 0; j < n;j++)
				if (cell[i][j].value == 3) {
					x = i; y = j;
				}

		int mini = x, minj = y;
		cell[mini][minj].color = 2147480000;

		CELL*now = NULL, *temp = NULL;
		now = cell[mini] + minj; 
		map[mini][minj] = 'a';
		while (cell[mini][minj].color>1) {
			for (i = 1; i <= 4; i++) {
				temp = around(now, i);
				if (temp && (temp->value != 0 && temp->color != 0 || temp->value == 4))
					if (cell[mini][minj].color>temp->color) {
						mini = temp->x; minj = temp->y;
					}
			}
			now = cell[mini] + minj;
			if(now->color%50==0)map[mini][minj] = '@';
			else map[mini][minj] = 'O';
		}
		map[mini][minj] = 'r';

		for (i = 0; i < m; i++) {
			for (j = 0; j < n; j++)
				printf("%c|", map[i][j]);
			printf("\n");
			delete[]map[i];
		}

		delete[] map;

		return;
	}
	
	void inputformscanf() {
		char *temp = new char[n];
		for (i = 0; i < m; i++) {
			scanf("%s", temp);
			for (j = 0; j < n; j++) {
				cell[i][j].set(i, j, temp[j]);
				temp[j] = 0;
			}
		}
		return;
	}

	void inputformlogistic(double a, double x0, double wall, double x, int sx, int sy, int ex, int ey) {
		double xnext;
		for (i = 0; i < m; i++)for (j = 0; j < n; j++) {
			cell[i][j] = { i,j,0,0 };
			xnext = x0*(1 - x0)*a;
			if (x0 > wall) { cell[i][j].value = 0; cell[i][j].color = 1; }
			else if (x0 >= x)cell[i][j].value = 2;
			else cell[i][j].value = 1;
			x0 = xnext;
		}
		cell[sx][sy].value = 4; cell[sx][sy].color = 0;
		cell[ex][ey].value = 3; cell[ex][ey].color = 0;
		return;
	}

};

int main() {
	int m, n;
	SOLVE sence;
	int re;
	int fplot = 0;
	if (0) {
		while (~scanf("%d%d", &m, &n)) {
			sence.newandset(m, n);

			sence.inputformscanf();
			re = sence.fun();
			if (re > 0) {
				printf("%d\n", re);
				if (fplot)sence.printpath();
			}
			else printf("Poor ANGEL has to stay in the prison all his life.\n");
			if (fplot)sence.print();

			sence.del();
		}
	}


	else if(1){
		fplot = 1;
		m = 109; n = 109; double a; char temp[8] = "";

		while (1) {
			int ia;
			scanf("%d", &ia);
				for (int it = 0; it < 8; it++)temp[it] = 0;
				sprintf(temp, "3.%d", ia);
				sscanf(temp, "%lf", &a);

			double w = 0.84, w2;
			int remax = 0; double wm = 0, wm2 = 0;
			for (int iw = 750; iw < 1000; iw ++) {
				for (int it = 0; it < 8; it++)temp[it] = 0;
				sprintf(temp, "0.%d", iw);
				sscanf(temp, "%lf", &w);
				w2 = w - 0.07;
				sence.newandset(m, n);
				sence.inputformlogistic(a, 0.65, w, w2, 1, 1, m - 3, n - 3);
				re = sence.fun();
				if (remax < re)remax = re, wm = w, wm2 = w2;
				sence.del();
			}
			w = wm, w2 = wm2;
			sence.newandset(m, n);
			sence.inputformlogistic(a, 0.65, w, w2, 1, 1, m - 3, n - 3);
			re = sence.fun();
			if (re > 0) {
				printf("%d  a=%.3lf  w=%.3lf\n", re, a, w);
				if (fplot) { sence.printpath(); sence.qc.printdata(); }
			}
			else printf("Poor ANGEL has to stay in the prison all his life.\n");
			if (fplot)sence.print();
			sence.del();
		}
	}
	//！这里有发现2次运行结果存在不一致
	else {
		fplot = 1;
		m = 109; n = 109; double a; char temp[8] = "";
		
		for (int ia = 600; ia < 1000; ia++) {
			for (int it = 0; it < 8; it++)temp[it] = 0;
			sprintf(temp, "3.%d", ia);
			sscanf(temp, "%lf", &a);

			double w = 0.84, w2;
			int remax = 0; double wm = 0, wm2 = 0;
			for (int iw = 750; iw < 1000; iw++) {
				for (int it = 0; it < 8; it++)temp[it] = 0;
				sprintf(temp, "0.%d", iw);
				sscanf(temp, "%lf", &w);
				w2 = w - 0.07;
				sence.newandset(m, n);
				sence.inputformlogistic(a, 0.65, w, w2, 1, 1, m - 3, n - 3);
				re = sence.fun();
				if (remax < re)remax = re, wm = w, wm2 = w2;
				sence.del();
			}
			w = wm, w2 = wm2;
			sence.newandset(m, n);
			sence.inputformlogistic(a, 0.65, w, w2, 1, 1, m - 3, n - 3);
			re = sence.fun();
			if (re > 0) {
				printf("%d  a=%.3lf  w=%.3lf\n", re, a, w);
				if (fplot) { sence.printpath(); sence.qc.printdata(); }
			}
			else printf("Poor ANGEL has to stay in the prison all his life.\n");
			if (fplot)sence.print();
			sence.del();
		}
	};
	return 0;
};
